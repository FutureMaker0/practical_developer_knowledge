# 체계적인 자원 관리

## 자바 메모리 관리
  - C언어는 할당한 메모리를 직접 해제해줘야 한다.
  - 자바는 메모리 해제 함수가 따로 없기 때문에 개발자가 직접 메모리를 해제할 수는 없다.
  - JVM(Java Virtual Machine)이라고 하는 가상 머신이 이 역할을 수행한다.

## JVM(Java Virtual Machine)
  - 자바 애플리케이션이 사용하지 않는 메모리를 찾아내 주기적으로 정리하는데, 이 과정을 가비지 컬렉션(garbage collection) 이라고 한다.
  - 접근하는 프로세스가 있는 메모리는 사용 중으로 판단하고, 그렇지 않은 메모리는 사용하지 않는다고 판단한다.

## Garbage Collection 발생 시점
> Visual VM과 같은 자원 모니터링 도구를 활용하여 heap 메모리 크기를 관찰하여 메모리 누수 여부를 확인할 수 있다.
> 전반적으로 우상향 하는 그래프일 때, 가비지 정리가 제대로 되지 않아 메모리 누수가 발생하는 것으로 판단할 수 있다.
  - 예제 코드 1
    ```java
    String exData = new String("exData");
    System.out.println(exData);
    ```
    - new를 통해 문자열 객체를 생성하면 heap 영역에 메모리를 할당하고, 해당 위치의 주소를 반환하여 반환된 주소 값을 exData 변수에 할당한다. 이후 exData를 통해 메모리에
      접근하면, 이 메모리는 사용 중인 것으로 판단하여 가비지 컬렉션의 대상이 아니다.
  - 예제 코드 2
    ```java
    String exData = new String("exData");
    System.out.println(exData);
    exData = null;
    ```
    - exData 변수에 null을 주면 더 이상 메모리를 참조할 수 없게 된다. 메모리 주소를 참조하는 변수가 존재하지 않기 때문에 가비지 컬렉션의 대상이 된다.
    - 특정 변수에 null을 주면 모두 가비지 컬렉션의 대상이 되느냐? 그렇지 않다.
  - 예제 코드 3
    ```java
    String exData = new String("exData");
    String exData2 = null;
    
    exData2 = exData;

    exData = null;
    ```
    - exData를 마지막에 null로 주었기 때문에 가비지 컬렉션이 되상이 될 것 같지만 그렇지 않다.
    - exData 변수가 가지고 있는 주소 값을 exData2 변수에 복사하여 여전히 메모리 값을 참조하여 사용하기 있기 떄문이다.
    - 그렇기 때문에 exData = null 코드 라인은 작용하지 않아 exData는 가비지 컬렉션의 대상이 되지 않는다.
  - 예제 코드 4
    ```java
    String exData = new String("exData");
    String exData2 = null;
    
    exData2 = exData;

    exData = null;
    exData2 = null;
    ```
    - JVM이 메모리 해제하도록 하기 위해서는 exData, exData2 모두 명시적으로 null을 할당해주어야 한다. 이렇게 하면 메모리를 참조하는 변수가 없어져 더 이상 사용되지 않는
      메모리로 판단하여 가비지 컬렉션을 시작한다.

## 스레드 풀링
  - 관련 용어 정리
    - 프로그램: 하드디스크에 저장된 바이너리 코드
    - 프로세스: 실행을 위해 메모리에 적재된 프로그램, CPU에 의해 실행중이거나 주기억장치에 적재된 프로그램과 데이터
    - 스레드: 프로세스 내부에서 실행되는 흐름의 단위
    - 멀티 스레드: 일반적으로 프로그램은 하나의 스레드를 갖지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행하는 방식
    - 멀티 스레딩: 멀티스레드 방식을 사용하여 CPU가 하나 이상의 작업을 동시에 처리하는 것
  - ABOUT thread pool
    - 애플리케이션은 동시에 여러 작업을 처리하기 위해 여러 개의 스레드를 생성한다.
    - 최적의 작업 효율을 위해 스레드 풀이라는 것을 만들어놓고 활용한다.
    - 작업 처리를 위해 무한정 스레드를 생성하지 않고, 프로그램을 시작할 때 고정 갯수의 스레드를 미리 생성해놓고 풀 형태로 제공하는 것이다.
    - 작업을 처리할 때 가용한 스레드를 이용한다.
    - 스레드 풀을 활용하면, 스레드가 이미 생성되어있어 별도 생성 절차를 거치지 않아 작업을 빨리 할당하고, 컴퓨팅 자원의 양을 고려하여 스레드 생성 갯수를 제한할 수 있다.
  - WAS(Web Application Service)에서의 스레드 풀링
    - 동작 순서
      1. 클라이언트 요청
      2. 접수 스레드 - 접수 창구에서 접수
      3. 대기 큐 - 접수 후 대기
      4. 요청 처리 스레드 - 불러서 처리
    - 동작 원리
      - WAS가 시작될 때 일정 갯수만큼의 스레드 풀이 만들어진다.
      - 클라이언트 요청이 많아지면 동시 요청 처리를 위해 더 많은 스레드를 생성하게 되는데, 서버 자원의 고려 없이 무한 생산하기 때문에 어느 시점에서 서버 자원이 고갈되면 요청 처리를
        위한 스레드가 부족해질 수 있다. 이렇게 되면 웹 서버에서 일부 작업이 처리되지 못해 대기 큐에서 계속 대기하게 되고, 클라이언트로의 응답 시간이 지연된다.
    - 효율적 작업 처리를 위한 스레드 풀 설정 방법
      
    













    
